#coding=utf-8
__author__ = 'anewhop7@gmail.com'
import Queue
import sys
import re
import urlparse
import requests
import datetime
import time
import socket
import threading
import ConfigParser
import struct
import os.path
import traceback
from optparse import OptionParser
from lib.consle_width import getTerminalSize
from netaddr import *
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
reload(sys)
sys.setdefaultencoding('utf-8')

now = datetime.datetime.now()
CONFIG_DIR='config'
TARGET_DIR='target'
DICT_DIR='dict'
USER_DIR = DICT_DIR + '/' + 'user'
PASS_DIR = DICT_DIR + '/' + 'pass'
USER_PASS_DIR = DICT_DIR + '/' +'user_pass'
FRAMEWORK_LOG_DIR = "log"+"/framework/"+str(now.year)+"/"+str(now.month)+"/"+str(now.day)
PLUGIN_LOG_DIR = "log"+"/plugin/"+str(now.year)+"/"+str(now.month)+"/"+str(now.day)
config_file="config.ini"
target_file="target"
format='###################'
now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
now=format+" "+now+"  "+" ".join(sys.argv)+" "+format+"\n"

def file_extension(filename): 
  return os.path.splitext(filename)[1][1:]

def file_basename(filename):
  return os.path.splitext(filename)[0]    

def intersect(a,b):
  return list(set(a).intersection(set(b)))

class dynamic_import:  
      def __init__(self,module_name,sub_mod):  
          self.module_name = module_name 
          self.sub_mod = sub_mod          
          self.module = None  
      def __getattr__(self,name):  
          if self.module is None:  
             self.module = __import__(self.module_name,fromlist = self.sub_mod)  
          return getattr(self.module,name)
          
class Multi_exp:
    scan_count = found_count = 0
    conf= ConfigParser.ConfigParser()
    lock = threading.Lock()
    console_width = getTerminalSize()[0] - 2# Cal terminal width when starts up
    target_list=[]
    scan_queue = Queue.Queue()
    start_time=time.time()
    STOP_ME = False
    if not os.path.exists(FRAMEWORK_LOG_DIR):
        os.makedirs(FRAMEWORK_LOG_DIR)
    if not os.path.exists(PLUGIN_LOG_DIR):
        os.makedirs(PLUGIN_LOG_DIR)

    def __init__(self,config_file,target_file,scan_type,scan_threads_count,show_plugins,exps):
        self.scan_threads_count = scan_threads_count      
        self.config_file = CONFIG_DIR+"/"+config_file
        self.scan_type = scan_type
        if "|" not in target_file:
            self.target_file = TARGET_DIR+"/"+target_file
        else:
            self.target_file = target_file
        self._get_all_plugins()
        self.show_plugins=show_plugins
        if exps== "NONE":
            self.exps=[]
        elif exps== "ALL":
            self.exps= self.plugins
        else:
            self.exps= intersect(exps.split(','),self.plugins)
        if self.show_plugins:
            self._println_msg("The available plugins are listed here:",align='left')
            for plug in self.plugins:
                self._println_msg("[*]"+plug,align='left')
            sys.exit(0)
        self._load_config_file()
        self._load_target_file()        
        
    def _load_config_file(self):
        self.conf.read(self.config_file)
        try:
            self.general_pass = self.conf.get("general", "password").strip().split(',')
        except:
            self.general_pass = []
        try:
            self.pass_file= self.conf.get("general", "pass_file").strip().split(",")
        except:
            self.pass_file= []
        
    def _load_target_file(self):
        if '|' in self.target_file:
            #username|password
            self.target_list.append(self.target_file.split('|'))
            return
        f_in=open(self.target_file)
        iter_f=iter(f_in)
        for line in iter_f:
            #username|password or username
            line = line.strip()
            self.target_list.append(line.split('|'))    
        print "Load target finish."
        
    def _update_scan_count(self):
        self.lock.acquire()
        self.scan_count += 1
        self.lock.release()
        
    def _update_find_count(self):
        self.lock.acquire()
        self.found_count += 1
        self.lock.release()
        
    def _set_found_count(self,count):
        self.lock.acquire()
        self.found_count = count
        self.lock.release()
        
    def _print_progress(self):
        msg = '%s found | %s remaining | %s scanned in %.2f seconds' % (self.found_count, self.scan_queue.qsize(), self.scan_count, time.time() - self.start_time)
        self._print_msg(msg)
    
    def _print_progress_daemo(self):
        while True:
            if self.scan_queue.qsize()==0:
                break
            self._print_progress()
            time.sleep(1)
    
    def _print_msg(self,msg):
        self.lock.acquire()
        try:
            sys.stdout.write('\r' + ' ' * (self.console_width -len(msg)) + msg)
            sys.stdout.flush()
        except Exception,e:
            pass
        self.lock.release()
        
    def _println_msg(self,msg,align='right'):
        self.lock.acquire()
        if align == 'left':
            try:
                sys.stdout.write('\r' + msg+"\n\r")
                sys.stdout.flush()
            except Exception,e:
                pass
        else:
            try:
                sys.stdout.write('\r' + ' ' * (self.console_width -len(msg)) + msg+"\n\r")
                sys.stdout.flush()
            except Exception,e:
                pass
        self.lock.release()
        
    def _write_file(self,filename,msg):
        self.lock.acquire()
        with open(filename,'a') as f:
            f.write(msg)
        self.lock.release()
        
    def _writeln_file(self,filename,msg):
        now=time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time.time()))
        self._write_file(filename,""+now+" "+msg+'\n')
    
    def _get_all_plugins(self):
        self.plugins=[]    
        for f in os.listdir('exp'):
            if file_extension(f) == 'py' and file_basename(f) not in ["__init__","plugin"] and f[0]!='[':
                self.plugins.append(file_basename(f))   

    def _merge_list(self,list1,list2):
        l1=len(list1)
        l2=len(list2)
        if l1<100 and l2>10000 and l2>2*l1*l1:
            list2.extend(list1)
            #print len(list2)
            return list2
        if l2<100 and l1>10000 and l1>2*l2*l2:
            list1.extend(list2)
            #print len(list1)
            return list1
        for l in list2:
            if l not in list1:
                list1.append(l)
        return list1

    def _get_dict_from_file(self,filename):
        d=[]
        try:
            with open(filename,'r') as f:
                iter_f=iter(f)
                for line in iter_f:
                    tmp=line.split("#")[0].strip()
                    if len(tmp) !=0 and tmp not in d:
                        d.append(tmp)
        except:
            pass
        return list(set(d))
        
    def _get_dict_from_files(self,pass_dir,filenames):
        dicts=[]
        for filename in filenames:
            d = self._get_dict_from_file(pass_dir+"/"+filename)
            dicts.extend(d)
        return list(set(dicts))

    def _gen_task_queue(self):
        self.scan_queue = Queue.Queue()
        ############### load exps ###############
        #scan_type,scan_application,username,password
        for exp in self.exps:
            print '\nbegin to generate %s task queue' % exp
            self._write_file(FRAMEWORK_LOG_DIR+"/"+exp+".log",now)
            if self.scan_type == "probe":
                for target in self.target_list:
                    username = target[0]
                    if not username:
                        continue
                    self.scan_queue.put((self.scan_type,exp,username))
            elif self.scan_type == "crack":
                pass_dict=self._get_dict_from_files(PASS_DIR,self.pass_file)
                #password = self._merge_list(password,pass_dict)
                password = self._merge_list(pass_dict,self.general_pass)
                for target in self.target_list:
                    username = target[0]
                    if not username:
                        continue
                    if len(target) == 2:
                        pwd = target[1]
                        self.scan_queue.put((self.scan_type,exp,username,pwd))
                    for pwd in password:
                        self.scan_queue.put((self.scan_type,exp,username,pwd))
                self.scan_queue.put((self.scan_type,exp,username,username))
            else:
                print("""scan_type must be "probe" or crack.""")
                continue
        print('generate all task queue finish')
        print("queue size: %s " % self.scan_queue.qsize())
        print("target count: %s " % len(self.target_list))

        
    def _scan(self):
        while self.scan_queue.qsize() > 0 and not self.STOP_ME:
            try:
                sub = self.scan_queue.get(timeout=1.0)                    
            except:
                break
            self._update_scan_count()
            scan_type,scan_application = sub[0],sub[1] #probe/crack,baidu
            ################### other scan #################
            s_t = dynamic_import('exp.'+scan_application,(scan_application,'exploit'))
            if scan_type == "probe":
                vector = (sub[2],)#user
            elif scan_type == "crack":
                vector = (sub[2],sub[3])#user, password
            else:
                err_msg = "not implented yet."
                msg = ("%s:%s %s:%s" % (scan_type,vector[0],scan_application,err_msg)).ljust(30)
                self._writeln_file(FRAMEWORK_LOG_DIR+"/"+scan_application+".log",msg)
                continue
            try:
                scan = s_t.exploit(PLUGIN_LOG_DIR,vector)
                if scan_type == "probe":
                    res=scan.probe()
                elif scan_type == "crack":
                    res=scan.crack()
                msg = (scan_application + ',' + ','.join(res[1:])).ljust(30)
                if res[0]:
                    self._update_find_count()
                    self._println_msg(msg)
                    self._writeln_file(FRAMEWORK_LOG_DIR+"/"+scan_application+".log",msg)
                else:
                    self._writeln_file(FRAMEWORK_LOG_DIR+"/"+scan_application+".not_vuln.log",msg)
            except Exception,e:
                traceback.print_exc()
                self._writeln_file(FRAMEWORK_LOG_DIR+"/"+scan_application+".exception.log","Exception:"+str(e))
                continue
        self.lock.acquire()
        self.scan_threads_count -= 1
        self.lock.release()
        self._print_progress()
            
    def run(self):  
        self.found_count = 0#found_count increase from 0 everytime
        self._gen_task_queue()
        t = threading.Thread(target=self._print_progress_daemo)   
        t.setDaemon(True)       
        t.start()
        #run every cycle
        for i in range(self.scan_threads_count):
            t = threading.Thread(target=self._scan, name=str(i))
            t.setDaemon(True)
            t.start()
            
        while self.scan_threads_count >= 1:
            try:
                time.sleep(1.0)
            except KeyboardInterrupt,e:
                msg = '[WARNING] User aborted, wait all slave threads to exit...'
                sys.stdout.write('\r' + msg + ' ' * (self.console_width- len(msg)) + '\n\r')
                sys.stdout.flush()
                while self.scan_queue.qsize() > 0:
                    self.scan_queue.get()                   
                self.STOP_ME = True
            
def main():
    options = OptionParser(usage='%prog [options]', description='powerful_scanner: a fast tool to exploit many targets,any bug please contact %s' % eval("_"+"_au"+"th"+"or_"+"_"))
    options.add_option('-c', '--config', dest='config_file',  type="string",default=config_file, help='config file in Directory ./%s/ to use(default:%s)' % (CONFIG_DIR,config_file))
    options.add_option('-u', '--user', dest='target_file',  type="string",default=target_file, help='target file in Directory ./%s/ to use(default:%s).Note:If you just want to test immediately with a single ip and port,you can use like this "-u username|password"' % (TARGET_DIR,target_file))
    options.add_option('-T', '--type', dest='scan_type',  type="string",default="probe", help='type of scan, including "probe" and "crack"')
    options.add_option('-t', '--scanthread', dest='scan_thread', type='int', default=63, help='Threads number to scan(default: 63)')
    options.add_option('--plugins', action='store_true', dest='show_plugins',  default=False, help='display all the available plugins(default: False)')    
    options.add_option('-e', '--exp', dest='exp',  type="string",default='NONE', help='which exp to exploit,no .py needed,eg:pwn1,pwn2(default:NONE)') 
    opts, args = options.parse_args()
    exp=Multi_exp(
                    config_file = opts.config_file,
                    target_file = opts.target_file,
                    scan_type = opts.scan_type,
                    scan_threads_count=opts.scan_thread,
                    show_plugins=opts.show_plugins,                    
                    exps=opts.exp
                 )
    exp.run()
if __name__ == '__main__':
    main()